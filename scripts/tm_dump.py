import re
import json

# Constants matching the C config
MAX_NUM_TMHMS = 128
TM_LEARNSETS_BITS_PER_WORD = 32
TM_LEARNSETS_BITFIELD_COUNT = MAX_NUM_TMHMS // TM_LEARNSETS_BITS_PER_WORD

def load_species_header(file_path):
    species_dict = {}
    index = 0
    with open(file_path) as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            symbol = parts[1]
            if (
                    "SPECIES" in symbol
                    and "_START" not in symbol
                    and "_H" not in symbol
                    and "MAX_" not in symbol
                    and "_NUM" not in line
            ):
                species_dict[symbol] = index
                index += 1
    return species_dict

def load_moves_header(file_path):
    moves_dict = {}
    index = 0
    with open(file_path) as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            symbol = parts[1]
            if (
                    "MOVE" in symbol
                    and "_START" not in symbol
                    and "_H" not in symbol
                    and "NUM_OF" not in symbol
            ):
                moves_dict[symbol] = index
                index += 1
    return moves_dict

def parse_tmhm_c_file(c_path):
    """
    Parses the static const u16 sTMHMMoves[] definition from a C source file.
    Returns a list of move names (e.g., ["MOVE_FOCUS_PUNCH", ...])
    """
    move_list = []
    in_array = False
    move_pattern = re.compile(r'\bMOVE_[A-Z0-9_]+')

    with open(c_path, encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if 'static const u16 sTMHMMoves[]' in line:
                in_array = True
                continue
            if in_array:
                if '};' in line:
                    break
                matches = move_pattern.findall(line)
                move_list.extend(matches)

    return move_list


def generate_tm_learnset_c_file(tmhm_moves, species_dict, moves_dict, species_learnsets, output_path="../data/TMLearnsets.c"):
    # Build TM/HM move name -> bit index map
    tm_move_to_index = {}
    for tmhm_index, move_name in enumerate(tmhm_moves):
        if move_name in moves_dict:
            tm_move_to_index[move_name] = tmhm_index

    max_species_index = max(species_dict.values())
    index_to_species = {v: k for k, v in species_dict.items()}

    with open(output_path, "w") as out:
        out.write("// DO NOT MODIFY THIS FILE!  autogenerated by scripts/tm_dump.py\n\n")
        out.write("#include \"../include/types.h\"\n")
        out.write("#include \"../include/config.h\"\n")
        out.write("#include \"../include/pokemon.h\"\n")
        out.write("#include \"../include/constants/species.h\"\n")
        out.write("#include \"../include/constants/item.h\"\n\n")
        out.write(f"const u32 UNUSED TMLearnsets[][TM_LEARNSETS_BITFIELD_COUNT] = {{\n")

        for i in range(max_species_index + 1):
            if i in index_to_species:
                species_name = index_to_species[i]
                learnset = species_learnsets.get(species_name, {}).get("TMMoves", [])
                learnset = list(set(m.strip() for m in learnset))  # dedupe + strip
                parts = [0] * TM_LEARNSETS_BITFIELD_COUNT

                for move in learnset:
                    tm_index = tm_move_to_index.get(move)
                    if tm_index is not None and tm_index < MAX_NUM_TMHMS:
                        word = tm_index // TM_LEARNSETS_BITS_PER_WORD
                        bit = tm_index % TM_LEARNSETS_BITS_PER_WORD
                        parts[word] |= (1 << bit)
                formatted = ", ".join(f"0x{val:08X}" for val in parts)
                out.write(f"    [{species_name}] = {{ {formatted} }},\n")
            else:
                zeroes = ", ".join("0x00000000" for _ in range(TM_LEARNSETS_BITFIELD_COUNT))
                out.write(f"    [{i}] = {{ {zeroes} }}, // unused\n")

        out.write("};\n")

if __name__ == "__main__":
    tmhm_moves = parse_tmhm_c_file("../src/item.c")
    species_dict = load_species_header("../include/constants/species.h")
    moves_dict = load_moves_header("../include/constants/moves.h")

    with open("../armips/data/learnsets.json", encoding="utf-8") as f:
        species_learnsets = json.load(f)

    generate_tm_learnset_c_file(
        tmhm_moves,
        species_dict,
        moves_dict,
        species_learnsets,
        output_path="../data/TMLearnsets.c"
    )
